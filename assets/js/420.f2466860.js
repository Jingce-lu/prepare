(window.webpackJsonp=window.webpackJsonp||[]).push([[420],{773:function(t,a,s){"use strict";s.r(a);var n=s(1),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"正则表达式不要背"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式不要背","aria-hidden":"true"}},[t._v("#")]),t._v(" 正则表达式不要背")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E8%A6%81%E8%83%8C"}},[t._v("正则表达式不要背")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E4%BB%8E%E5%AD%97%E7%AC%A6%E5%87%BA%E5%8F%91"}},[t._v("从字符出发")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6"}},[t._v("单个字符")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6"}},[t._v("多个字符")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E5%BE%AA%E7%8E%AF%E4%B8%8E%E9%87%8D%E5%A4%8D"}},[t._v("循环与重复")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#0--1"}},[t._v("0 | 1")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#-0"}},[t._v(">= 0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#-1"}},[t._v(">= 1")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E7%89%B9%E5%AE%9A%E6%AC%A1%E6%95%B0"}},[t._v("特定次数")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E4%BD%8D%E7%BD%AE%E8%BE%B9%E7%95%8C"}},[t._v("位置边界")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C"}},[t._v("单词边界")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%B9%E7%95%8C"}},[t._v("字符串边界")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"}},[t._v("子表达式")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%88%86%E7%BB%84"}},[t._v("分组")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E5%9B%9E%E6%BA%AF%E5%BC%95%E7%94%A8"}},[t._v("回溯引用")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#%E5%89%8D%E5%90%91%E6%9F%A5%E6%89%BE"}},[t._v("前向查找")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E5%90%8E%E5%90%91%E6%9F%A5%E6%89%BE"}},[t._v("后向查找")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86"}},[t._v("逻辑处理")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#%E6%9C%80%E5%90%8E"}},[t._v("最后")])])])])]),t._v(" "),s("h2",{attrs:{id:"从字符出发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从字符出发","aria-hidden":"true"}},[t._v("#")]),t._v(" 从字符出发")]),t._v(" "),s("p",[t._v("正则表达式的基本组成元素可以分为："),s("code",[t._v("字符")]),t._v("和"),s("code",[t._v("元字符")]),t._v("。\n字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。"),s("br"),t._v("\n而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。\n利用这些元字符，才能构造出强大的表达式模式(pattern)")]),t._v(" "),s("h2",{attrs:{id:"单个字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单个字符","aria-hidden":"true"}},[t._v("#")]),t._v(" 单个字符")]),t._v(" "),s("p",[t._v("最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在'apple'这个单词里找到"),s("code",[t._v("‘a'")]),t._v("这个字符，就直接用"),s("code",[t._v("/a/")]),t._v("这个正则就可以了。\n但是如果想要匹配特殊字符的话，就得请出我们第一个元字符"),s("code",[t._v("**\\**")]),t._v("， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子：\n我想匹配"),s("code",[t._v("*")]),t._v("这个符号，由于"),s("code",[t._v("*")]),t._v("这个符号本身是个特殊字符，所以我要利用转义元字符\\来让它失去其本来的含义：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/\\*/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。为了便于记忆，我整理了下面这个表格，并附上记忆方式：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("特殊字符")]),t._v(" "),s("th",[t._v("正则表达式")]),t._v(" "),s("th",[t._v("记忆方式")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("换行符")]),t._v(" "),s("td",[t._v("\\n")]),t._v(" "),s("td",[t._v("new line")])]),t._v(" "),s("tr",[s("td",[t._v("换页符")]),t._v(" "),s("td",[t._v("\\f")]),t._v(" "),s("td",[t._v("form feed")])]),t._v(" "),s("tr",[s("td",[t._v("回车符")]),t._v(" "),s("td",[t._v("\\r")]),t._v(" "),s("td",[t._v("return")])]),t._v(" "),s("tr",[s("td",[t._v("空白符")]),t._v(" "),s("td",[t._v("\\s")]),t._v(" "),s("td",[t._v("space")])]),t._v(" "),s("tr",[s("td",[t._v("制表符")]),t._v(" "),s("td",[t._v("\\t")]),t._v(" "),s("td",[t._v("tab")])]),t._v(" "),s("tr",[s("td",[t._v("垂直制表符")]),t._v(" "),s("td",[t._v("\\v")]),t._v(" "),s("td",[t._v("vertical tab")])]),t._v(" "),s("tr",[s("td",[t._v("回退符")]),t._v(" "),s("td",[t._v("[\\b]")]),t._v(" "),s("td",[t._v("backspace,之所以使用[]符号是避免和\\b重复")])])])]),t._v(" "),s("h2",{attrs:{id:"多个字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多个字符","aria-hidden":"true"}},[t._v("#")]),t._v(" 多个字符")]),t._v(" "),s("p",[t._v("单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。")]),t._v(" "),s("p",[t._v("在正则表达式里，集合的定义方式是使用中括号"),s("code",[t._v("[")]),t._v("和"),s("code",[t._v("]")]),t._v("。如"),s("code",[t._v("/[123]/")]),t._v("这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符-就可以用来表示区间范围，利用"),s("code",[t._v("/[0-9]/")]),t._v("就能匹配所有的数字, "),s("code",[t._v("/[a-z]/")]),t._v("则可以匹配所有的英文小写字母。")]),t._v(" "),s("p",[t._v("即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式:")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("匹配区间")]),t._v(" "),s("th",[t._v("正则表达式")]),t._v(" "),s("th",[t._v("记忆方式")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("除了换行符之外的任何字符")]),t._v(" "),s("td",[t._v(".")]),t._v(" "),s("td",[t._v("句号,除了句子结束符")])]),t._v(" "),s("tr",[s("td",[t._v("单个数字, [0-9]")]),t._v(" "),s("td",[t._v("\\d")]),t._v(" "),s("td",[t._v("digit")])]),t._v(" "),s("tr",[s("td",[t._v("除了[0-9]")]),t._v(" "),s("td",[t._v("\\D")]),t._v(" "),s("td",[t._v("not digit")])]),t._v(" "),s("tr",[s("td",[t._v("包括下划线在内的单个字符，[A-Za-z0-9_]")]),t._v(" "),s("td",[t._v("\\w")]),t._v(" "),s("td",[t._v("word")])]),t._v(" "),s("tr",[s("td",[t._v("非单字字符")]),t._v(" "),s("td",[t._v("\\W")]),t._v(" "),s("td",[t._v("not word")])]),t._v(" "),s("tr",[s("td",[t._v("匹配空白字符,包括空格、制表符、换页符和换行符")]),t._v(" "),s("td",[t._v("\\s")]),t._v(" "),s("td",[t._v("space")])]),t._v(" "),s("tr",[s("td",[t._v("匹配非空白字符")]),t._v(" "),s("td",[t._v("\\S")]),t._v(" "),s("td",[t._v("not space")])])])]),t._v(" "),s("h2",{attrs:{id:"循环与重复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#循环与重复","aria-hidden":"true"}},[t._v("#")]),t._v(" 循环与重复")]),t._v(" "),s("p",[t._v("一对一和一对多的字符匹配都讲完了。接下来，就该介绍如何同时匹配多个字符。要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。")]),t._v(" "),s("h3",{attrs:{id:"_0-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0-1","aria-hidden":"true"}},[t._v("#")]),t._v(" 0 | 1")]),t._v(" "),s("p",[t._v("元字符"),s("code",[t._v("?")]),t._v("代表了匹配一个字符或0个字符。设想一下，如果你要匹配"),s("code",[t._v("color")]),t._v("和"),s("code",[t._v("colour")]),t._v("这两个单词，就需要同时保证"),s("code",[t._v("u")]),t._v("这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的："),s("code",[t._v("/colou?r/")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0","aria-hidden":"true"}},[t._v("#")]),t._v(" >= 0")]),t._v(" "),s("p",[t._v("元字符"),s("code",[t._v("*")]),t._v("用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。")]),t._v(" "),s("h3",{attrs:{id:"_1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1","aria-hidden":"true"}},[t._v("#")]),t._v(" >= 1")]),t._v(" "),s("p",[t._v("元字符"),s("code",[t._v("+")]),t._v("适用于要匹配同个字符出现1次或多次的情况。")]),t._v(" "),s("h3",{attrs:{id:"特定次数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特定次数","aria-hidden":"true"}},[t._v("#")]),t._v(" 特定次数")]),t._v(" "),s("p",[t._v("在某些情况下，我们需要匹配特定的重复次数，元字符"),s("code",[t._v("{")]),t._v("和"),s("code",[t._v("}")]),t._v("用来给重复匹配设置精确的区间范围。如'a'我想匹配3次,那么我就使用"),s("code",[t._v("/a{3}/")]),t._v("这个正则，或者说'a'我想匹配至少两次就是用"),s("code",[t._v("/a{2,}/")]),t._v("这个正则。")]),t._v(" "),s("p",[t._v("以下是完整的语法：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" x次\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("min"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" max"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("： 介于min次到max次之间\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("min"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 至少min次\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" max"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("： 至多max次\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("p",[t._v("由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("匹配规则")]),t._v(" "),s("th",[t._v("元字符")]),t._v(" "),s("th",[t._v("联想方式")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("0次或1次")]),t._v(" "),s("td",[t._v("?")]),t._v(" "),s("td",[t._v("且问,此事有还无")])]),t._v(" "),s("tr",[s("td",[t._v("0次或无数次")]),t._v(" "),s("td",[t._v("*")]),t._v(" "),s("td",[t._v("宇宙洪荒,辰宿列张：宇宙伊始，从无到有，最后星宿布满星空")])]),t._v(" "),s("tr",[s("td",[t._v("1次或无数次")]),t._v(" "),s("td",[t._v("+")]),t._v(" "),s("td",[t._v("一加, +1")])]),t._v(" "),s("tr",[s("td",[t._v("特定次数")]),t._v(" "),s("td",[t._v("{x}, {min, max}")]),t._v(" "),s("td",[t._v("可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界")])])])]),t._v(" "),s("h2",{attrs:{id:"位置边界"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#位置边界","aria-hidden":"true"}},[t._v("#")]),t._v(" 位置边界")]),t._v(" "),s("p",[t._v("上面我们把字符的匹配都介绍完了，接着我们还需要位置边界的匹配。在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。")]),t._v(" "),s("h3",{attrs:{id:"单词边界"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单词边界","aria-hidden":"true"}},[t._v("#")]),t._v(" 单词边界")]),t._v(" "),s("p",[t._v("单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("The cat scattered his food all over the room"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("我想找到"),s("code",[t._v("cat")]),t._v("这个单词，但是如果只是使用"),s("code",[t._v("/cat/")]),t._v("这个正则，就会同时匹配到"),s("code",[t._v("cat")]),t._v("和"),s("code",[t._v("scattered")]),t._v("这两处文本。这时候我们就需要使用边界正则表达式"),s("code",[t._v("\\b")]),t._v("，其中b是boundary的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。")]),t._v(" "),s("p",[t._v("上面的例子改写成"),s("code",[t._v("/\\bcat\\b/")]),t._v("这样就能匹配到"),s("code",[t._v("cat")]),t._v("这个单词了。")]),t._v(" "),s("h3",{attrs:{id:"字符串边界"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串边界","aria-hidden":"true"}},[t._v("#")]),t._v(" 字符串边界")]),t._v(" "),s("p",[t._v("匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符"),s("code",[t._v("^")]),t._v("用来匹配字符串的开头。而元字符"),s("code",[t._v("$")]),t._v("用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配"),s("code",[t._v("I am scq000")]),t._v("这个句子：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("I")]),t._v(" am scq000"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("I")]),t._v(" am scq000"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("I")]),t._v(" am scq000"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("我们可以使用"),s("code",[t._v("/^I am scq000\\.$/m")]),t._v("这样的正则表达式，其实m是multiple line的首字母。正则里面的模式除了m外比较常用的还有i和g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。")]),t._v(" "),s("p",[t._v("最后，总结一下：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("边界和标志")]),t._v(" "),s("th",[t._v("正则表达式")]),t._v(" "),s("th",[t._v("记忆方式")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("单词边界")]),t._v(" "),s("td",[t._v("\\b")]),t._v(" "),s("td",[t._v("boundary")])]),t._v(" "),s("tr",[s("td",[t._v("非单词边界")]),t._v(" "),s("td",[t._v("\\B")]),t._v(" "),s("td",[t._v("not boundary")])]),t._v(" "),s("tr",[s("td",[t._v("字符串开头")]),t._v(" "),s("td",[t._v("^")]),t._v(" "),s("td",[t._v("小头尖尖那么大个")])]),t._v(" "),s("tr",[s("td",[t._v("字符串结尾")]),t._v(" "),s("td",[t._v("$")]),t._v(" "),s("td",[t._v("终结者，美国科幻电影，美元符$")])]),t._v(" "),s("tr",[s("td",[t._v("多行模式")]),t._v(" "),s("td",[t._v("m标志")]),t._v(" "),s("td",[t._v("multiple of lines")])]),t._v(" "),s("tr",[s("td",[t._v("忽略大小写")]),t._v(" "),s("td",[t._v("i标志")]),t._v(" "),s("td",[t._v("ignore case, case-insensitive")])]),t._v(" "),s("tr",[s("td",[t._v("全局模式")]),t._v(" "),s("td",[t._v("g标志")]),t._v(" "),s("td",[t._v("global")])])])]),t._v(" "),s("h2",{attrs:{id:"子表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#子表达式","aria-hidden":"true"}},[t._v("#")]),t._v(" 子表达式")]),t._v(" "),s("p",[t._v("字符匹配我们介绍的差不多了，更加高级的用法就得用到子表达式了。通过嵌套递归和自身引用可以让正则发挥更强大的功能。")]),t._v(" "),s("p",[t._v("从简单到复杂的正则表达式演变通常要采用"),s("strong",[t._v("分组、回溯引用和逻辑处理")]),t._v("的思想。利用这三种规则，可以推演出无限复杂的正则表达式。")]),t._v(" "),s("h3",{attrs:{id:"分组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分组","aria-hidden":"true"}},[t._v("#")]),t._v(" 分组")]),t._v(" "),s("p",[t._v("其中分组体现在：所有以"),s("code",[t._v("(")]),t._v("和"),s("code",[t._v(")")]),t._v("元字符所包含的正则表达式被分为一组，每一个分组都是一个"),s("strong",[t._v("子表达式")]),t._v("，它也是构成高级正则表达式的基础。如果只是使用简单的"),s("code",[t._v("(regex)")]),t._v("匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。")]),t._v(" "),s("h3",{attrs:{id:"回溯引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯引用","aria-hidden":"true"}},[t._v("#")]),t._v(" 回溯引用")]),t._v(" "),s("p",[t._v("所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像"),s("code",[t._v("\\1")]),t._v(","),s("code",[t._v("\\2")]),t._v(",....,其中"),s("code",[t._v("\\1")]),t._v("表示引用的第一个子表达式，"),s("code",[t._v("\\2")]),t._v("表示引用的第二个子表达式，以此类推。而"),s("code",[t._v("\\0")]),t._v("则表示整个表达式。")]),t._v(" "),s("p",[t._v("假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Hello what what is the first thing"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" and "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("I")]),t._v(" am am scq000"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("利用回溯引用，我们可以很容易地写出"),s("code",[t._v("\\b(\\w+)\\s\\1")]),t._v("这样的正则。")]),t._v(" "),s("p",[t._v("回溯引用在替换字符串中十分常用，语法上有些许区别，用"),s("code",[t._v("$1")]),t._v(","),s("code",[t._v("$2")]),t._v("...来引用要被替换的字符串。下面以js代码作演示：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" str "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'abc abc 123'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(ab)c/g")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'$1g'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 得到结果 'abg abg 123'")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("如果我们不想子表达式被引用，可以使用"),s("strong",[t._v("非捕获")]),t._v("正则"),s("code",[t._v("(?:regex)")]),t._v("这样就可以避免浪费内存。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" str "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'scq000'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nstr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(scq00)(?:0)/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'$1,$2'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回scq00,$2")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。")]),t._v(" "),s("h4",{attrs:{id:"前向查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前向查找","aria-hidden":"true"}},[t._v("#")]),t._v(" 前向查找")]),t._v(" "),s("p",[t._v("前向查找(lookahead)是用来限制后缀的。凡是以"),s("code",[t._v("(?=regex)")]),t._v("包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如"),s("code",[t._v("happy happily")]),t._v("这两个单词，我想获得以"),s("code",[t._v("happ")]),t._v("开头的副词，那么就可以使用"),s("code",[t._v("happ(?=ily)")]),t._v("来匹配。如果我想过滤所有以"),s("code",[t._v("happ")]),t._v("开头的副词，那么也可以采用负前向查找的正则"),s("code",[t._v("happ(?!ily)")]),t._v("，就会匹配到"),s("code",[t._v("happy")]),t._v("单词的"),s("code",[t._v("happ")]),t._v("前缀。")]),t._v(" "),s("h4",{attrs:{id:"后向查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后向查找","aria-hidden":"true"}},[t._v("#")]),t._v(" 后向查找")]),t._v(" "),s("p",[t._v("介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： "),s("code",[t._v("apple")]),t._v("和"),s("code",[t._v("people")]),t._v("都包含"),s("code",[t._v("ple")]),t._v("这个后缀，那么如果我只想找到"),s("code",[t._v("apple")]),t._v("的"),s("code",[t._v("ple")]),t._v("，该怎么做呢？我们可以通过限制app这个前缀，就能唯一确定"),s("code",[t._v("ple")]),t._v("这个单词了。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(?<=app)ple/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("其中"),s("code",[t._v("(?<=regex)")]),t._v("的语法就是我们这里要介绍的后向查找。"),s("code",[t._v("regex")]),t._v("指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向后查找。另外一种限制匹配是利用"),s("code",[t._v("(?<!regex)")]),t._v(" 语法，这里称为负后向查找。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找"),s("code",[t._v("apple")]),t._v("的"),s("code",[t._v("ple")]),t._v("也可以这么写成"),s("code",[t._v("/(?<!peo)")]),t._v("ple。")]),t._v(" "),s("p",[t._v("需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。看一个简单的例子：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如我想替换apple的ple为ply")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" str "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'apple people'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("split")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("join")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/elp(?=pa)/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'ylp'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("split")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("join")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("最后回顾一下这部分内容：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("回溯查找")]),t._v(" "),s("th",[t._v("正则")]),t._v(" "),s("th",[t._v("记忆方式")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("引用")]),t._v(" "),s("td",[t._v("\\0,\\1,\\2 和 $0, $1, $2")]),t._v(" "),s("td",[t._v("转义+数字")])]),t._v(" "),s("tr",[s("td",[t._v("非捕获组")]),t._v(" "),s("td",[t._v("(?😃")]),t._v(" "),s("td",[t._v("引用表达式(()), 本身不被消费(?),引用(😃")])]),t._v(" "),s("tr",[s("td",[t._v("前向查找")]),t._v(" "),s("td",[t._v("(?=)")]),t._v(" "),s("td",[t._v("引用子表达式(())，本身不被消费(?), 正向的查找(=)")])]),t._v(" "),s("tr",[s("td",[t._v("前向负查找")]),t._v(" "),s("td",[t._v("(?!)")]),t._v(" "),s("td",[t._v("引用子表达式(())，本身不被消费(?), 负向的查找(!)")])]),t._v(" "),s("tr",[s("td",[t._v("后向查找")]),t._v(" "),s("td",[t._v("(?<=)")]),t._v(" "),s("td",[t._v("引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=)")])]),t._v(" "),s("tr",[s("td",[t._v("后向负查找")]),t._v(" "),s("td",[t._v("(?<!)")]),t._v(" "),s("td",[t._v("引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!)")])])])]),t._v(" "),s("h3",{attrs:{id:"逻辑处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#逻辑处理","aria-hidden":"true"}},[t._v("#")]),t._v(" 逻辑处理")]),t._v(" "),s("p",[t._v("计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。")]),t._v(" "),s("p",[t._v("在正则里面，默认的正则规则都是与的关系所以这里不讨论。")]),t._v(" "),s("p",[t._v("而非关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用"),s("code",[t._v("^")]),t._v("这个元字符。在这里要着重记忆一下：只有在"),s("code",[t._v("[")]),t._v("和"),s("code",[t._v("]")]),t._v("内部使用的"),s("code",[t._v("^")]),t._v("才表示非的关系。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式"),s("code",[t._v("(?!regex)")]),t._v("或后向负查找子表达式"),s("code",[t._v("(?<!regex)")]),t._v("。")]),t._v(" "),s("p",[t._v("或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用"),s("code",[t._v("(a|b)")]),t._v("这样的子表达式。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("逻辑关系")]),t._v(" "),s("th",[t._v("正则元字符")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("与")]),t._v(" "),s("td",[t._v("无")])]),t._v(" "),s("tr",[s("td",[t._v("非")]),t._v(" "),s("td",[t._v("[^regex]和!")])]),t._v(" "),s("tr",[s("td",[t._v("或")]),t._v(" "),s("td",[t._v("丨")])])])]),t._v(" "),s("h2",{attrs:{id:"最后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最后","aria-hidden":"true"}},[t._v("#")]),t._v(" 最后")]),t._v(" "),s("p",[t._v("在最后，出个常用的正则面试题吧：请写出一个正则来处理数字千分位，如"),s("code",[t._v("12345")]),t._v("替换为"),s("code",[t._v("12,345")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("splitNum")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/\\B(?=(?:\\d{3})+\\b)/g")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("','")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("splitNum")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1234567.333333")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "1,234,567.333,333"')]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" num "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'12345678'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nnum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\d)(?=(\\d{3})+$)/g")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'$1,'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nnum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/\\d{1,3}(?=(\\d{3})+$)/g")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'$&,'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nnum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/\\B(?=(\\d{3})+$)/g")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("','")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以上三种的 $都可以替换成\\b的形式.")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])])])}),[],!1,null,null,null);a.default=e.exports}}]);