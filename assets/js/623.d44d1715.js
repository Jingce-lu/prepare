(window.webpackJsonp=window.webpackJsonp||[]).push([[623],{863:function(v,_,l){"use strict";l.r(_);var i=l(1),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"一个页面从输入-url-到加载显示完成，发生了什么？"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#一个页面从输入-url-到加载显示完成，发生了什么？","aria-hidden":"true"}},[v._v("#")]),v._v(" 一个页面从输入 URL 到加载显示完成，发生了什么？")]),v._v(" "),l("ul",[l("li",[l("a",{attrs:{href:"#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"}},[v._v("一个页面从输入 URL 到加载显示完成，发生了什么？")]),v._v(" "),l("ul",[l("li",[l("a",{attrs:{href:"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"}},[v._v("计算机网络")])]),v._v(" "),l("li",[l("a",{attrs:{href:"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6"}},[v._v("浏览器机制")]),v._v(" "),l("ul",[l("li",[l("a",{attrs:{href:"#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"}},[v._v("进程和线程的概念")])]),v._v(" "),l("li",[l("a",{attrs:{href:"#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8"}},[v._v("多进程的浏览器")])]),v._v(" "),l("li",[l("a",{attrs:{href:"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B"}},[v._v("浏览器内核（渲染进程）")])])])]),v._v(" "),l("li",[l("a",{attrs:{href:"#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"}},[v._v("一个页面从输入 URL 到加载显示完成，这个过程发生了什么？")])]),v._v(" "),l("li",[l("a",{attrs:{href:"#webpack-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86"}},[v._v("webpack 热更新原理")])]),v._v(" "),l("li",[l("a",{attrs:{href:"#%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8E%BB%E7%A0%94%E7%A9%B6-webpack-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"}},[v._v("有没有去研究 webpack 的一些原理和机制，怎么实现的")])])])])]),v._v(" "),l("h2",{attrs:{id:"_1-计算机网络"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-计算机网络","aria-hidden":"true"}},[v._v("#")]),v._v(" 1.计算机网络")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("五层因特尔协议栈：")]),v._v(" "),l("ul",[l("li",[v._v("应用层（dns、http）：DNS 解析成 IP 并完成 http 请求发送；")]),v._v(" "),l("li",[v._v("传输层（tcp、udp）：三次握手四次挥手模式建立 tcp 连接；")]),v._v(" "),l("li",[v._v("网络层（IP、ARP）：IP 寻址；")]),v._v(" "),l("li",[v._v("数据链路层（PPP）：将请求数据封装成帧；")]),v._v(" "),l("li",[v._v("物理层：利用物理介质传输比特流（传输的时候通过双绞线、电磁波等）")]),v._v(" "),l("li",[l("strong",[v._v("OIS 七层框架")]),v._v(":多了两层即，会话层（处理两个通信系统中交换信息的表示方式）和表示层（管理不同用户和进程之间的对话）。")])])]),v._v(" "),l("li",[l("p",[v._v("get 和 post 的区别：")]),v._v(" "),l("ul",[l("li",[v._v("get 产生一个 tcp 数据包，post 产生两个")]),v._v(" "),l("li",[v._v("get 请求时会把 headers 和 data 数据一起发送出去；")]),v._v(" "),l("li",[v._v("post 请求时，浏览器先发送 headers，服务器 100 继续，浏览器再发送 data。")])])]),v._v(" "),l("li",[l("p",[v._v("DNS 查询得到 IP")]),v._v(" "),l("ol",[l("li",[v._v("请求信息：首先查看域名的本地 DNS 缓存，该缓存存储计算机最近检索到的信息，如果计算机不知道答案，那么就需要执行一个 DNS 查询来查找答案；")]),v._v(" "),l("li",[v._v("询问递归式 DNS 服务器：\n"),l("ul",[l("li",[v._v("如果信息不存储在本地，计算机会联系您的 ISP（网络提供商）的递归 DNS 服务器；")]),v._v(" "),l("li",[v._v("这些专用计算机会为你执行一个 DNS 查询工作；")]),v._v(" "),l("li",[v._v("递归服务器有自己的缓存，所以这个查询过程通常在这里完成，并将信息还回给用户；")])])]),v._v(" "),l("li",[v._v("询问根域名服务器\n"),l("ul",[l("li",[v._v("如果递归服务器没有答案，他们会查询根域名服务器；")]),v._v(" "),l("li",[v._v("根域名服务器是一种计算机，它扮演着一种 DNS 的电话接线员的角色，他们不知道答案，但可以将我们的疑问指向知道在哪里可以找到答案的人。")])])]),v._v(" "),l("li",[v._v("询问 TLD 域名服务器：\n"),l("ul",[l("li",[v._v("根域名服务器将查看请求的第一部分，按从右到左的顺序，从 www.dyn.com 中找到.com，并将请求指向.com 对应的顶级域名服务器（TLD）.com;")]),v._v(" "),l("li",[v._v("每个 TLD，如（.com,.org,.us）都有自己的顶级域名服务器，")]),v._v(" "),l("li",[v._v("这些服务器没有我们需要的信息，但他们可以直接将我们引导到有信息的服务器。")])])]),v._v(" "),l("li",[v._v("询问权威的 DNS 服务器\n"),l("ul",[l("li",[v._v("TLD 域名服务器会继续检查请求的下一部分（dyn）www.dyn.com，并将查询指向负责此特定域名的服务器；")]),v._v(" "),l("li",[v._v("这些权威的服务器将负责了解关于特定域的所有信息，并将信息存储在 DNS 记录。")])])]),v._v(" "),l("li",[v._v("找回记录："),l("br"),v._v("\n递归服务器从权威服务器中检索 dyn.com 的记录，并将记录存储在本地缓存；\n"),l("ul",[l("li",[v._v("如果其他任何人请求 dyn.com 的主机记录，递归服务器已经有答案了，并不需要再次进行查找；")]),v._v(" "),l("li",[v._v("所有记录都有一个期限，一段时间后，递归服务器将需要要求一个新的记录副本，以确保信息不回过时。")])])]),v._v(" "),l("li",[v._v("接收答案：\n"),l("ul",[l("li",[v._v("有了答案，递归服务器将记录返回到计算机，")]),v._v(" "),l("li",[v._v("您的计算机将记录存储在缓存中，从记录中读取 IP 地址，然后将这些信息传递给浏览器；")]),v._v(" "),l("li",[v._v("然后浏览器就可以根据 IP 地址和服务器进行连接建立。")])])])])]),v._v(" "),l("li",[l("p",[v._v("TCPIP 请求")]),v._v(" "),l("ul",[l("li",[v._v("http 的本质就是 TCPIP 请求；")]),v._v(" "),l("li",[v._v("需要经历 3 次握手建立连接，4 次挥手断开连接；")]),v._v(" "),l("li",[v._v("TCP 将 http 长报文划分为短报文，通过三次握手与服务器端建立连接，进行可靠传输。")]),v._v(" "),l("li",[l("strong",[v._v("三次握手")]),v._v("：\n"),l("ol",[l("li",[v._v("客户端：你是 XXX 服务端吗？")]),v._v(" "),l("li",[v._v("服务端： 我是 XXX 服务端，你是客户端吗？")]),v._v(" "),l("li",[v._v("客服端： 是的，我是客户端\n建立连接成功后，接下来就可以进行正式的传输数据。")])])]),v._v(" "),l("li",[l("strong",[v._v("四次挥手断开连接")]),v._v(" "),l("ol",[l("li",[v._v("主动方：我已经关闭了向你那边的信息发送通道，只能被动接受信息了；")]),v._v(" "),l("li",[v._v("被动方： 收到通道关闭的信息；")]),v._v(" "),l("li",[v._v("被动方： 我现在也关闭了向你那边发送信息的通道")]),v._v(" "),l("li",[v._v("主动方： 左后收到信息，连接断开，之后双方无法通信")])])])])]),v._v(" "),l("li",[l("p",[v._v("TCP/IP 的并发限制：")]),v._v(" "),l("ul",[l("li",[v._v("浏览器对同一个域名下并发的 TCP 连接是有限制的（2-10 个不等）")]),v._v(" "),l("li",[v._v("而且在 http1.0 中往往一个资源的下载就需要一个 tcp/ip 请求")])])])]),v._v(" "),l("h2",{attrs:{id:"浏览器机制"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#浏览器机制","aria-hidden":"true"}},[v._v("#")]),v._v(" 浏览器机制")]),v._v(" "),l("h3",{attrs:{id:"进程和线程的概念"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的概念","aria-hidden":"true"}},[v._v("#")]),v._v(" 进程和线程的概念")]),v._v(" "),l("ol",[l("li",[v._v("进程是 CPU 资源分配的最小单位，是能拥有资源和独立运行的最小单位；")]),v._v(" "),l("li",[v._v("线程是 CPU 调度的最小单位，线程是建立在进程的基础上的一次程序运行单位，一个进程可以拥有多个线程；")]),v._v(" "),l("li",[v._v("通俗的讲：进程是一个工厂，工厂有它独立的资源，工厂之间相互独立->进程之间相互独立，线程是工厂中的工人，多个工人之间可以协作完成任务，工厂内有一个或多个工人，工人之间共享空间。")])]),v._v(" "),l("h3",{attrs:{id:"多进程的浏览器"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#多进程的浏览器","aria-hidden":"true"}},[v._v("#")]),v._v(" 多进程的浏览器")]),v._v(" "),l("blockquote",[l("p",[v._v("浏览器是多进程的，有一个主控进程，以及每一个 tab 页面都会开一个进程（某些情况下多个 tab 由于优化策略会合并）")])]),v._v(" "),l("p",[v._v("浏览器主要进程：")]),v._v(" "),l("ol",[l("li",[v._v("Browser 进程：浏览器的主进程，负责协调、主控，只有一个，作用：\n"),l("ul",[l("li",[v._v("负责浏览器界面的显示、与用户交互（如前进、后退等）")]),v._v(" "),l("li",[v._v("负责各个页面的管理，创建和销毁其他进程；")]),v._v(" "),l("li",[v._v("将 Renderer 进程得到的内存中的 Bitmap 绘制到用户界面上")]),v._v(" "),l("li",[v._v("网络资源的管理和下载等")])])]),v._v(" "),l("li",[v._v("第三方插件进程： 每种类型的插件对应一个进程，仅当该插件使用时才创建；")]),v._v(" "),l("li",[v._v("GPU 进程： 最多一个，用于 3D 绘制等；")]),v._v(" "),l("li",[v._v("浏览器渲染进程（Renderer 进程、浏览器内核、内部是多线程）：\n"),l("ul",[l("li",[v._v("默认没打开一个 tab 页面，就会启动一个 Renderer 进程；")]),v._v(" "),l("li",[v._v("负责页面的渲染，脚本的执行，事件的处理。")])])])]),v._v(" "),l("p",[v._v("浏览器多进程的优势")]),v._v(" "),l("ol",[l("li",[v._v("避免单个 page crash 影响整个浏览器；")]),v._v(" "),l("li",[v._v("避免第三方插件 crash 影响整个浏览器")]),v._v(" "),l("li",[v._v("多进程充分利用多核优势；")]),v._v(" "),l("li",[v._v("方便使用沙盒模型隔离插件等进程，提高浏览器稳定性")])]),v._v(" "),l("blockquote",[l("p",[v._v("简单点理解：如果浏览器是单进程，那么某个 tab 页或第三方插件崩溃了，就会导致整个浏览器崩溃，体验度极差，不过多进程内存消耗会更大，有点用空间换时间。")])]),v._v(" "),l("h3",{attrs:{id:"浏览器内核（渲染进程）"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核（渲染进程）","aria-hidden":"true"}},[v._v("#")]),v._v(" 浏览器内核（渲染进程）")]),v._v(" "),l("p",[v._v("浏览器渲染进程内部是多线程，包含主要线程有：")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("GUI 渲染线程：")]),v._v(" "),l("ul",[l("li",[v._v("（1）负责浏览器界面的渲染，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等；")]),v._v(" "),l("li",[v._v("（2） 当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时该线程会执行；")]),v._v(" "),l("li",[l("strong",[v._v("注意：GUI 渲染线程和 JS 引擎线程是互斥的")]),v._v("，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会保存在一个队列中等 JS 引擎空闲时立即执行。")])])]),v._v(" "),l("li",[l("p",[v._v("JS 引擎线程：")]),v._v(" "),l("ul",[l("li",[v._v("JS 内核，负责处理 JavaScript 脚本程序（V8 引擎）")]),v._v(" "),l("li",[v._v("负责解析 JavaScript 脚本，运行代码；")]),v._v(" "),l("li",[v._v("JS 引擎一直等待着任务队列中的任务到来，然后加以处理，一个 tab 页面（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序；")]),v._v(" "),l("li",[l("strong",[v._v("注意：由于 GUI 渲染线程和 JS 引擎线程是互斥的")]),v._v("，所以如果 JS 程序运行时间过长，这样会导致页面渲染不连贯，导致页面渲染加载阻塞；")])])]),v._v(" "),l("li",[l("p",[v._v("事件触发线程：")]),v._v(" "),l("ul",[l("li",[v._v("归属于浏览器，而不是 JS 引擎，用来控制事件循环；")]),v._v(" "),l("li",[v._v("当 JS 引擎执行代码块如 setTimeOut 时（也可以来自浏览器内核的其他线程，如鼠标单击事件、AJAX 异步请求等），会将对应的任务添加到事件线程中；")]),v._v(" "),l("li",[v._v("当对应的事件符合触发条件被触发时，该线程就会把事件添加到 JS 的待处理队列的队尾，等待 JS 引擎的处理；")]),v._v(" "),l("li",[l("strong",[v._v("注意：由于 JS 的单线程的关系")]),v._v("所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）。")])])]),v._v(" "),l("li",[l("p",[v._v("定时触发器线程：")]),v._v(" "),l("ul",[l("li",[v._v("setTimeOut 与 setInterval 所在的线程；")]),v._v(" "),l("li",[v._v("浏览器的定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 是单线程，如果处于阻塞状态就会影响计时的准确）因此通过单独的线程来计时并触发定时（计时完毕后，添加到事件队列，等待 JS 引擎空闲时执行）")])])]),v._v(" "),l("li",[l("p",[v._v("异步 http 请求线程：")]),v._v(" "),l("ul",[l("li",[v._v("在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求的")]),v._v(" "),l("li",[v._v("将检测到状态变更时，如果设置有回调函数，异步线程就将产生状态变更事件，将这个回调在放到事件队列中，再由 JavaScript 引擎执行。")])])])]),v._v(" "),l("h2",{attrs:{id:"一个页面从输入-url-到加载显示完成，这个过程发生了什么？"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#一个页面从输入-url-到加载显示完成，这个过程发生了什么？","aria-hidden":"true"}},[v._v("#")]),v._v(" 一个页面从输入 URL 到加载显示完成，这个过程发生了什么？")]),v._v(" "),l("p",[v._v("简洁版：")]),v._v(" "),l("ul",[l("li",[v._v("浏览器根据请求的 URL 交给 DNS 域名解析，找到真实的 IP，向服务器发起请求；")]),v._v(" "),l("li",[v._v("服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、CSS、JavaScript 等）；")]),v._v(" "),l("li",[v._v("浏览器对加载到的资源（HTML、CSS、JavaScript 等）进行语法解析，构建相应的内部数据结构（DOM 树、CSS 树、render 树等）；")]),v._v(" "),l("li",[v._v("载入解析到的资源文件、渲染页面、完成。")])]),v._v(" "),l("p",[v._v("详细版：")]),v._v(" "),l("ol",[l("li",[v._v("首先浏览器开启一个线程来处理这个请求，对 URL 分析判断，如果是 http 协议就按照 Web 方式来处理；")]),v._v(" "),l("li",[v._v("其次浏览器会对 URL 进行解析，一般包括（协议头、主机域名或 IP 地址、端口号、请求路径、查询参数、hash 等），然后开启网络线程发出一个完整到 http 请求；")]),v._v(" "),l("li",[v._v("当然一般我们输入的 URL 是服务器域名，这时就需要 DNS 通过域名查询得到对应的 IP；")]),v._v(" "),l("li",[v._v("DNS 首先会查看浏览器 DNS 缓存，没有就查询计算机本地 DNS 缓存，还没有就询问递归式 DNS 服务器（即网络提供商，一般这个服务器都会有自己的缓存，所以 IP 查询一般在这里完成），如果没有缓存，那就需要通过根域名和 TLD 域名服务器指到对应的权威 DNS 服务器找回记录，并缓存到递归式服务器，然后递归服务器在将记录返回给本地。")]),v._v(" "),l("li",[v._v("有了 IP 地址，此时网络层便会通过 IP 地址寻的对应服务器的物理地址")]),v._v(" "),l("li",[v._v("寻得服务器地址，客户端在网络传输层便可以和服务器通过三次握手建立 tcpip 连接")]),v._v(" "),l("li",[v._v("连接建立后网络数据链路层将数据包装成帧；")]),v._v(" "),l("li",[v._v("最后物理层利用物理介质进行传输；")]),v._v(" "),l("li",[v._v("到了服务器，就会通过相反的方式将数据一层一层的还原回去；")]),v._v(" "),l("li",[v._v("请求到了后台服务器，一般会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的 http 报文")]),v._v(" "),l("li",[v._v("验证通过后，就会进入后台代码，此时程序收到请求，然后执行对应的操作（如查询数据库等）；")]),v._v(" "),l("li",[v._v("如果浏览器访问过，且缓存上有对应的资源，便会与服务器最后修改时间对比，一致便返回 304，告诉浏览器可使用本地缓存；")]),v._v(" "),l("li",[v._v("前端浏览器接收到响应成功的报文后便开始下载网页")]),v._v(" "),l("li",[v._v("下载完的网页将被交给浏览器内核（渲染进程）进行处理：\n"),l("ol",[l("li",[v._v("根据顶部定义的 DTD 类型进行对应的解析方式；")]),v._v(" "),l("li",[v._v("渲染进程内部是多线程的，网页的解析将会被交给内部的 GUI 渲染线程处理；")]),v._v(" "),l("li",[v._v("首先渲染线程中的 HTML 解释器，将 HTML 网页和资源从字节流解释转换成字符流；")]),v._v(" "),l("li",[v._v("再通过词法分析器将字符流解释成词语；")]),v._v(" "),l("li",[v._v("之后经过语法分析器根据词语构建成节点；最后通过这些节点组建一个 DOM 树；")]),v._v(" "),l("li",[v._v("这个过程中，如果遇到的 DOM 节点是 JavaScript 代码，就会调用 JavaScript 引擎对 JavaScript 代码进行解释执行，此时由 JavaScript 引擎和 GUI 渲染线程的互斥，GUI 渲染线程就会被挂起，渲染过程停止；如果 JavaScript 代码的运行中对 DOM 树进行了修改，那么 DOM 的构建需要从新开始；")]),v._v(" "),l("li",[v._v("如果节点需要依赖其他资源，如（图片，CSS 等），便会调用网络模块的资源加载器来加载它们，但它们是异步的，不会阻塞当前 DOM 树的构建；")]),v._v(" "),l("li",[v._v("如果遇到的是 JavaScript 资源 URL（没有标记异步），则需要停止当前 DOM 的构建，直到 JavaScript 的资源加载并被 JavaScript 引擎执行后才继续构建 DOM；")]),v._v(" "),l("li",[v._v("对于 CSS，CSS 解释器会将 CSS 文件解释成内部表示结构，生成 CSS 规则树；")]),v._v(" "),l("li",[v._v("然后合并 CSS 规则树和 DOM 树，生成 render 渲染树；")]),v._v(" "),l("li",[v._v("最后对 render 树进行布局和绘制，并将结果通过 IO 线程传递给 Browser 控制进程进行显示。")])])])]),v._v(" "),l("h2",{attrs:{id:"_2-webpack-热更新原理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-webpack-热更新原理","aria-hidden":"true"}},[v._v("#")]),v._v(" 2.webpack 热更新原理")]),v._v(" "),l("ol",[l("li",[v._v("当修改了一个或多个文件；")]),v._v(" "),l("li",[v._v("文件系统接收更改并通知 webpack；")]),v._v(" "),l("li",[v._v("webpack 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；")]),v._v(" "),l("li",[v._v("HMR Server 使用 webSocket 通知 HMR runtime 需要更新，HMR 运行时通过 HTTP 请求更新 jsonp；")]),v._v(" "),l("li",[v._v("HMR 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。")])]),v._v(" "),l("h2",{attrs:{id:"_3-有没有去研究-webpack-的一些原理和机制，怎么实现的"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-有没有去研究-webpack-的一些原理和机制，怎么实现的","aria-hidden":"true"}},[v._v("#")]),v._v(" 3.有没有去研究 webpack 的一些原理和机制，怎么实现的")]),v._v(" "),l("ol",[l("li",[v._v("解析 webpack 配置参数，合并从 shell 传入和 webpack.config.js 文件里配置的参数，生产最后的配置结果。")]),v._v(" "),l("li",[v._v("注册所有配置的插件，好让插件监听 webpack 构建生命周期的事件节点，以做出对应的反应。")]),v._v(" "),l("li",[v._v("从配置的 entry 入口文件开始解析文件构建 AST 语法树，找出每个文件所依赖的文件，递归下去。")]),v._v(" "),l("li",[v._v("在解析文件递归的过程中根据文件类型和 loader 配置找出合适的 loader 用来对文件进行转换。")]),v._v(" "),l("li",[v._v("递归完后得到每个文件的最终结果，根据 entry 配置生成代码块 chunk。")]),v._v(" "),l("li",[v._v("输出所有 chunk 到文件系统。")])])])}),[],!1,null,null,null);_.default=t.exports}}]);