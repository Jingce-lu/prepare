(window.webpackJsonp=window.webpackJsonp||[]).push([[443],{683:function(t,a,e){"use strict";e.r(a);var r=e(1),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-1-20"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-1-20","aria-hidden":"true"}},[t._v("#")]),t._v(" React 1-20")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#react-1-20"}},[t._v("React 1-20")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#1react%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%99%A8"}},[t._v("1.react什么时候使用状态管理器？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#2react-render%E5%87%BD%E6%95%B0%E4%B8%ADreturn%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"}},[t._v("2.[react] render函数中return如果没有使用()会有什么问题？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#3react-componentwillupdate%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9state%E7%9A%84%E5%80%BC%E5%90%97"}},[t._v("3.[react] componentWillUpdate可以直接修改state的值吗？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#4%E4%BB%80%E4%B9%88%E6%B8%B2%E6%9F%93%E5%8A%AB%E6%8C%81"}},[t._v("4.什么渲染劫持？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#5react15%E5%92%8C16%E5%88%AB%E6%94%AF%E6%8C%81ie%E5%87%A0%E4%BB%A5%E4%B8%8A"}},[t._v("5.React15和16别支持IE几以上？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#6%E4%BD%A0%E6%9C%89%E7%94%A8%E8%BF%87react%E7%9A%84%E6%8F%92%E6%A7%BDportals%E5%90%97%E6%80%8E%E4%B9%88%E7%94%A8"}},[t._v("6.你有用过React的插槽(Portals)吗？怎么用？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8Ereact%E7%9A%84%E6%8F%92%E6%A7%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF"}},[t._v("7.举例说明React的插槽有哪些运用场景？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#8react%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E6%8B%86%E5%88%86%E7%9A%84%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"}},[t._v("8.React如何进行代码拆分？拆分的原则是什么？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#9react%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"}},[t._v("9.React组件的构造函数有什么作用？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#10react%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84%E5%90%97"}},[t._v("10.React组件的构造函数是必须的吗？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#11react%E4%B8%AD%E5%9C%A8%E5%93%AA%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF"}},[t._v("11.React中在哪捕获错误？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#12%E5%9C%A8react%E4%B8%AD%E4%BD%A0%E6%9C%89%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E5%90%97"}},[t._v("12.在React中你有经常使用常量吗？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#13%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4react%E4%B8%AD%E7%9A%84props%E6%98%AF%E5%8F%AA%E8%AF%BB%E7%9A%84"}},[t._v("13.为什么说React中的props是只读的？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#14react-router%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96url%E7%9A%84%E5%8F%82%E6%95%B0"}},[t._v("14.React-Router怎么获取URL的参数？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#15super%E5%92%8Csuperprops%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"}},[t._v("15."),e("code",[t._v("super()")]),t._v("和"),e("code",[t._v("super(props)")]),t._v("有什么区别？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#16%E9%9C%80%E8%A6%81%E6%8A%8Akeys%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E5%90%97"}},[t._v("16.需要把keys设置为全局唯一吗？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#17%E5%9C%A8history%E6%A8%A1%E5%BC%8F%E4%B8%ADpush%E5%92%8Creplace%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"}},[t._v("17.在history模式中push和replace有什么区别？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#18react-router-3%E5%92%8Creact-router-4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E7%89%B9%E6%80%A7"}},[t._v("18.React-Router 3和React-Router 4有什么变化？添加了什么好的特性？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#19react-router%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"}},[t._v("19.React-Router的实现原理是什么？")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#20react-router-4%E7%9A%84switch%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"}},[t._v("20.React-Router 4的switch有什么用？")])])])])]),t._v(" "),e("h2",{attrs:{id:"_1-react什么时候使用状态管理器？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-react什么时候使用状态管理器？","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.react什么时候使用状态管理器？")]),t._v(" "),e("p",[t._v("通过提升单个组件的复杂度,实现组件通讯")]),t._v(" "),e("h2",{attrs:{id:"_2-react-render函数中return如果没有使用-会有什么问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-react-render函数中return如果没有使用-会有什么问题？","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.[react] render函数中return如果没有使用()会有什么问题？")]),t._v(" "),e("p",[t._v("我们在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加"),e("code",[t._v("分号（；）")]),t._v("，如果return后换行了，那么就会变成 "),e("code",[t._v("return；")]),t._v(" 一般情况下会报错：")]),t._v(" "),e("blockquote",[e("p",[t._v("Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.")])]),t._v(" "),e("p",[t._v("上面这段英文翻译成中文：")]),t._v(" "),e("ul",[e("li",[t._v("渲染没有返回任何内容。这通常意味着缺少return语句。或者，为了不渲染，返回null。")])]),t._v(" "),e("p",[t._v("为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。")]),t._v(" "),e("p",[t._v("举两个正确的书写例子：")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Nav")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nav className"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"c_navbar"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" some jsx magic here "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("nav"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Nav")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nav className"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"c_navbar"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" some jsx magic here "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("nav"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br")])]),e("p",[t._v("错误的写法：")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Nav")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nav className"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"c_navbar"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" some jsx magic here "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("nav"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br")])]),e("h2",{attrs:{id:"_3-react-componentwillupdate可以直接修改state的值吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-react-componentwillupdate可以直接修改state的值吗？","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.[react] componentWillUpdate可以直接修改state的值吗？")]),t._v(" "),e("ol",[e("li",[t._v("不行，这样会导致无限循环报错。")]),t._v(" "),e("li",[t._v("在react中直接修改state，render函数不会重新执行渲染，应使用setState方法进行修改")])]),t._v(" "),e("p",[t._v("react组件在每次需要重新渲染时候都会调用"),e("code",[t._v("componentWillUpdate()")]),t._v(",")]),t._v(" "),e("p",[t._v("例如，我们调用 "),e("code",[t._v("this.setState()")]),t._v("时候")]),t._v(" "),e("p",[t._v("在这个函数中我们之所以不调用"),e("code",[t._v("this.setState()")]),t._v("是因为该方法会触发另一个"),e("code",[t._v("componentWillUpdate()")]),t._v(",如果我们"),e("code",[t._v("componentWillUpdate()")]),t._v("中触发状态更改,我们将以无限循环结束.")]),t._v(" "),e("h2",{attrs:{id:"_4-什么渲染劫持？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么渲染劫持？","aria-hidden":"true"}},[t._v("#")]),t._v(" 4.什么渲染劫持？")]),t._v(" "),e("p",[t._v("首先，"),e("strong",[t._v("什么是渲染劫持")]),t._v("：渲染劫持的概念是控制组件从另一个组件输出的能力，当然这个概念一般和react中的高阶组件（HOC）放在一起解释比较有明了。")]),t._v(" "),e("p",[e("strong",[t._v("高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出，只要改变了原组件的渲染，我们都将它称之为一种渲染劫持")]),t._v("。")]),t._v(" "),e("p",[t._v("实际上，在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可以增强由原组件render函数产生的React元素。")]),t._v(" "),e("p",[t._v("实际的操作中 通过 操作 state、props 都可以实现渲染劫持")]),t._v(" "),e("h2",{attrs:{id:"_5-react15和16别支持ie几以上？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-react15和16别支持ie几以上？","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.React15和16别支持IE几以上？")]),t._v(" "),e("p",[t._v("React15 版本不直接支持IE8 浏览器的，官方文档中说React16 中依赖于集合类型Map 和 Set 因此不再支持IE 11 以下的浏览器，如果想要支持，需要使用全局的 polyfill")]),t._v(" "),e("h2",{attrs:{id:"_6-你有用过react的插槽-portals-吗？怎么用？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-你有用过react的插槽-portals-吗？怎么用？","aria-hidden":"true"}},[t._v("#")]),t._v(" 6.你有用过React的插槽(Portals)吗？怎么用？")]),t._v(" "),e("ol",[e("li",[t._v("首先简单的介绍下react中的插槽（Portals），通过"),e("code",[t._v("ReactDOM.createPortal(child, container)")]),t._v("创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。")]),t._v(" "),e("li",[t._v("第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。")]),t._v(" "),e("li",[t._v("对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。")])]),t._v(" "),e("h2",{attrs:{id:"_7-举例说明react的插槽有哪些运用场景？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-举例说明react的插槽有哪些运用场景？","aria-hidden":"true"}},[t._v("#")]),t._v(" 7.举例说明React的插槽有哪些运用场景？")]),t._v(" "),e("p",[t._v("对于 "),e("code",[t._v("portal")]),t._v(" 的一个典型用例是当父组件有 "),e("code",[t._v("overflow: hidden")]),t._v(" 或 "),e("code",[t._v("z-index")]),t._v(" 样式，但你需要子组件能够在视觉上 “"),e("code",[t._v("跳出(break out)")]),t._v("” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的")]),t._v(" "),e("h2",{attrs:{id:"_8-react如何进行代码拆分？拆分的原则是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-react如何进行代码拆分？拆分的原则是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 8.React如何进行代码拆分？拆分的原则是什么？")]),t._v(" "),e("p",[t._v("这里我认为react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。")]),t._v(" "),e("p",[t._v("在我们的react项目中：")]),t._v(" "),e("ol",[e("li",[t._v("在 api 层面我们单独封装，对外暴露http请求的结果。")]),t._v(" "),e("li",[t._v("数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。")]),t._v(" "),e("li",[t._v("试图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。")]),t._v(" "),e("li",[t._v("静态类型的资源单独放置")]),t._v(" "),e("li",[t._v("公共组件、高阶组件、插件单独放置")]),t._v(" "),e("li",[t._v("工具类文件单独放置")])]),t._v(" "),e("h2",{attrs:{id:"_9-react组件的构造函数有什么作用？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-react组件的构造函数有什么作用？","aria-hidden":"true"}},[t._v("#")]),t._v(" 9.React组件的构造函数有什么作用？")]),t._v(" "),e("p",[t._v("在react的新的写法中，每一个组件都是一个类，这个很符合es6的语法规范，在es6中要想创建一个对象，就要调用相应的构造函数,一般来说，我们声明构造函数 是为了初始化组件内部的state 状态和绑定一些函数的this指向")]),t._v(" "),e("h2",{attrs:{id:"_10-react组件的构造函数是必须的吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-react组件的构造函数是必须的吗？","aria-hidden":"true"}},[t._v("#")]),t._v(" 10.React组件的构造函数是必须的吗？")]),t._v(" "),e("p",[t._v("构造函数并不是必须的,对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的")]),t._v(" "),e("h2",{attrs:{id:"_11-react中在哪捕获错误？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-react中在哪捕获错误？","aria-hidden":"true"}},[t._v("#")]),t._v(" 11.React中在哪捕获错误？")]),t._v(" "),e("p",[t._v("在react 15 极其以前的版本中,组件内的UI异常将中断组件内部状态，导致下一次渲染时触发隐藏异常。React并未提供友好的异常捕获和处理方式，一旦发生异常，应用将不能很好的运行。而React 16版本有所改进。")]),t._v(" "),e("p",[t._v("组件内异常，也就是异常边界组件能够捕获的异常，主要包括：")]),t._v(" "),e("ul",[e("li",[t._v("1、渲染过程中异常；")]),t._v(" "),e("li",[t._v("2、生命周期方法中的异常；")]),t._v(" "),e("li",[t._v("3、子组件树中各组件的constructor构造函数中异常。")])]),t._v(" "),e("p",[t._v("当然异常边界也有一些无法捕获的异常，主要是异步及服务端触发异常：")]),t._v(" "),e("ul",[e("li",[t._v("1、事件处理器中的异常；")]),t._v(" "),e("li",[t._v("2、异步任务异常，如setTiemout，ajax请求异常等；")]),t._v(" "),e("li",[t._v("3、服务端渲染异常；")]),t._v(" "),e("li",[t._v("4、异常边界组件自身内的异常；")])]),t._v(" "),e("h2",{attrs:{id:"_12-在react中你有经常使用常量吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-在react中你有经常使用常量吗？","aria-hidden":"true"}},[t._v("#")]),t._v(" 12.在React中你有经常使用常量吗？")]),t._v(" "),e("p",[t._v("在写react应用的时候，在结合redux 处理react 应用层中的数据层的时候, 会单独写一个actionType文件，这个文件中定义的都是常量，这样写的好处是，单纯的引入字符串内容，容易出错且很难排查，中间做这个文件做一个过渡，就是这种引用常量的方式")]),t._v(" "),e("h2",{attrs:{id:"_13-为什么说react中的props是只读的？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-为什么说react中的props是只读的？","aria-hidden":"true"}},[t._v("#")]),t._v(" 13.为什么说React中的props是只读的？")]),t._v(" "),e("p",[t._v("react官方文档中说道，组件无论是使用函数声明还是通过class声明，都绝不能修改自身的props，props 作为组件对外通信的一个接口，为了保证组件像纯函数一样没有响应的副作用，所有的组件都必须像纯函数一样保护它们的props不被修改")]),t._v(" "),e("h2",{attrs:{id:"_14-react-router怎么获取url的参数？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-react-router怎么获取url的参数？","aria-hidden":"true"}},[t._v("#")]),t._v(" 14.React-Router怎么获取URL的参数？")]),t._v(" "),e("ul",[e("li",[t._v("在之前的版本中，可以通过 "),e("code",[t._v("this.props.location.query.bar")]),t._v(" 进行获取")]),t._v(" "),e("li",[t._v("在 v4 中，通过 "),e("code",[t._v("this.props.location.search")]),t._v(" 获取，不过需要进行处理")])]),t._v(" "),e("h2",{attrs:{id:"_15-super-和super-props-有什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-super-和super-props-有什么区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 15."),e("code",[t._v("super()")]),t._v("和"),e("code",[t._v("super(props)")]),t._v("有什么区别？")]),t._v(" "),e("p",[e("code",[t._v("super()")]),t._v(" 可以让我们使用this来调用各种东西，\n而"),e("code",[t._v("super(props)")]),t._v("可以让我们在this的基础上使用构造函数里面的东西， 或者从父元素那边传过来的一些属性")]),t._v(" "),e("p",[t._v("如果只调用了"),e("code",[t._v("super()")]),t._v("，那么"),e("code",[t._v("this.props")]),t._v("在"),e("code",[t._v("super()")]),t._v("和构造函数结束之间仍是"),e("code",[t._v("undefined")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Button")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 没有传 props")]),t._v("\n    console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// {}")]),t._v("\n    console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined ")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br")])]),e("h2",{attrs:{id:"_16-需要把keys设置为全局唯一吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-需要把keys设置为全局唯一吗？","aria-hidden":"true"}},[t._v("#")]),t._v(" 16.需要把keys设置为全局唯一吗？")]),t._v(" "),e("p",[e("strong",[t._v("不需要")]),t._v(",key是用来进行diff算法的时候进行同层比较,准备的说key只需要在兄弟节点之间唯一,一般情况key选取是后端定义的id.万不得已的时候可以选择index(选择index是万不得已的选择,因为选择了index后,一些操作会改变index的值,违背了唯一不变,在进行diff算法的时候出现问题)")]),t._v(" "),e("h2",{attrs:{id:"_17-在history模式中push和replace有什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-在history模式中push和replace有什么区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 17.在history模式中push和replace有什么区别？")]),t._v(" "),e("p",[t._v("pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录，因此不会增加History.length。")]),t._v(" "),e("h2",{attrs:{id:"_18-react-router-3和react-router-4有什么变化？添加了什么好的特性？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-react-router-3和react-router-4有什么变化？添加了什么好的特性？","aria-hidden":"true"}},[t._v("#")]),t._v(" 18.React-Router 3和React-Router 4有什么变化？添加了什么好的特性？")]),t._v(" "),e("p",[t._v("React-Router 4 从设计思想上进行改变，引入动态路由，将路由进行了拆分，将其放到了各自的模块中，不再有单独的 router 模块，充分体现了组件化的思想，更加贴合 React 的思想。")]),t._v(" "),e("p",[t._v("具体表现：")]),t._v(" "),e("ul",[e("li",[t._v("包含式路由与exact\n"),e("ul",[e("li",[t._v("在之前的版本中，在 Route 中写入的 path，在路由匹配时是独一无二的，路由的嵌套体现在 "),e("code",[t._v("<Route>")]),t._v(" 组件的嵌套规则上")]),t._v(" "),e("li",[t._v('v4 版本则有了一个包含的关系：如匹配 path="/users" 的路由会匹配 path="/"的路由，在页面中这两个模块会同时进行渲染。')]),t._v(" "),e("li",[t._v("v4中多了 "),e("code",[t._v("exact")]),t._v(" 关键词，表示只对当前的路由进行匹配。")])])]),t._v(" "),e("li",[t._v("独立路由："),e("code",[t._v("Switch")]),t._v("（排他性路由）\n"),e("ul",[e("li",[t._v("采用 "),e("code",[t._v("<Switch>")]),t._v("，只有一个路由会被渲染，并且总是渲染第一个匹配到的组件")]),t._v(" "),e("li",[t._v("配合使用 "),e("code",[t._v("exact")])])])]),t._v(" "),e("li",[t._v('"Index Routes" 和 "Not Found"\n'),e("ul",[e("li",[t._v("废弃了 "),e("code",[t._v("<IndexRoute>")]),t._v("，而该用 "),e("code",[t._v("<Route exact>")]),t._v(" 的方式进行代替")]),t._v(" "),e("li",[t._v("如果没有匹配的路由，也可通过 "),e("code",[t._v("<Redirect>")]),t._v(" 来进行重定向到默认页面或合理的路径。")])])]),t._v(" "),e("li",[t._v("嵌套布局")]),t._v(" "),e("li",[t._v("授权路由")]),t._v(" "),e("li",[e("code",[t._v("<Link>")]),t._v(" vs "),e("code",[t._v("<NavLink>")])]),t._v(" "),e("li",[t._v("URL 查询字符串")])]),t._v(" "),e("h2",{attrs:{id:"_19-react-router的实现原理是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-react-router的实现原理是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 19.React-Router的实现原理是什么？")]),t._v(" "),e("p",[t._v("依赖 history 库，保证视图和 URL 的同步")]),t._v(" "),e("p",[t._v("用户可以通过手动输入或者与页面进行交互来改变 URL，然后向服务端发送请求获取资源，成功后重新绘制 UI。")]),t._v(" "),e("h2",{attrs:{id:"_20-react-router-4的switch有什么用？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-react-router-4的switch有什么用？","aria-hidden":"true"}},[t._v("#")]),t._v(" 20.React-Router 4的switch有什么用？")]),t._v(" "),e("p",[t._v("Switch排他性路由，采用 "),e("code",[t._v("<Switch>")]),t._v("，只有一个路由会被渲染，并且总是渲染第一个匹配到的组件，更好进行路由匹配。")])])}),[],!1,null,null,null);a.default=s.exports}}]);