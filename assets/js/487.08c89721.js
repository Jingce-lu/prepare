(window.webpackJsonp=window.webpackJsonp||[]).push([[487],{857:function(s,e,t){"use strict";t.r(e);var a=t(1),n=Object(a.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"nodejs-1-20"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-1-20","aria-hidden":"true"}},[s._v("#")]),s._v(" NodeJs 1-20")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#nodejs-1-20"}},[s._v("NodeJs 1-20")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#1-nodejs%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%BA%9B"}},[s._v("1. NodeJs的特性主要有哪些？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#2-nodejs%E9%80%82%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E5%BC%80%E5%8F%91"}},[s._v("2. NodeJs适用于哪些场景开发？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#3-%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95nodejs%E5%91%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"}},[s._v("3. 你是怎么调试NodeJs呢？有哪些方法？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#4-%E4%BD%A0%E7%9F%A5%E9%81%93nodejs%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%90%97"}},[s._v("4. 你知道NodeJs是如何工作的吗？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#5-nodejs%E5%92%8Cv8%E5%BC%95%E6%93%8E%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"}},[s._v("5. NodeJs和V8引擎是什么关系？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#6-nodejs%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88"}},[s._v("6. NodeJs是基于单线程的吗？为什么？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#7-nodejs%E6%97%A2%E7%84%B6%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9Eio"}},[s._v("7. nodejs既然是单线程，如何实现异步、非阻塞I/O？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#8-nodejs%E6%97%A2%E7%84%B6%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9Eio"}},[s._v("8. nodejs既然是单线程，如何实现异步、非阻塞I/O？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#9-nodejs%E5%85%A8%E6%98%AF%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9Eio%E5%B0%B1%E7%9C%9F%E7%9A%84%E4%B8%8D%E7%94%A8%E7%AE%A1%E5%B9%B6%E5%8F%91%E6%95%B0%E4%BA%86%E5%90%97"}},[s._v("9. nodejs全是异步调用和非阻塞I/O，就真的不用管并发数了吗？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#10-nodejs%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84event-loop%E6%98%AF%E4%B8%80%E5%9B%9E%E4%BA%8B%E5%90%97"}},[s._v("10. nodejs事件驱动是如何实现的？和浏览器的event loop是一回事吗？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#11-nodejs%E6%93%85%E9%95%BF%E4%BB%80%E4%B9%88%E4%B8%8D%E6%93%85%E9%95%BF%E4%BB%80%E4%B9%88"}},[s._v("11. nodejs擅长什么？不擅长什么？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#12-nodejs%E7%9A%84%E5%9B%9E%E8%B0%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%90%97"}},[s._v("12. NodeJs的回调有什么用吗？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#13-node%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1-%E5%92%8C-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%9C%89%E5%93%AA%E4%BA%9B"}},[s._v("13. Node的全局对象 和 全局变量有哪些？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#14-%E6%80%8E%E6%A0%B7%E5%9C%A8nodejs%E4%B8%AD%E5%8A%A0%E8%BD%BDhtml%E6%96%87%E4%BB%B6"}},[s._v("14. 怎样在NodeJs中加载HTML文件？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#15-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BD%A0%E5%AF%B9eventemitter%E7%9A%84%E7%90%86%E8%A7%A3"}},[s._v("15. 请解释下你对EventEmitter的理解")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#16-%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AFrepl%E5%90%97"}},[s._v("16. 你知道什么是REPL吗？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#17-npm%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E6%9C%89%E6%B2%A1%E6%9C%89%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%96%B9%E6%A1%88"}},[s._v("17. npm是干什么用的？它有什么优缺点？有没有类似的方案？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#18%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9packagejson%E7%9A%84%E7%90%86%E8%A7%A3%E5%AE%83%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8"}},[s._v("18.说说你对package.json的理解，它都有哪些作用？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#19-%E4%BD%A0%E4%BA%86%E8%A7%A3nodejs%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%90%97"}},[s._v("19. 你了解NodeJs的子进程吗？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#20-%E4%BD%A0%E7%94%A8nodejs%E5%81%9A%E8%BF%87%E4%BB%80%E4%B9%88%E9%A1%B9%E7%9B%AE"}},[s._v("20. 你用NodeJs做过什么项目？")])])])])]),s._v(" "),t("h2",{attrs:{id:"_1-nodejs的特性主要有哪些？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-nodejs的特性主要有哪些？","aria-hidden":"true"}},[s._v("#")]),s._v(" 1. NodeJs的特性主要有哪些？")]),s._v(" "),t("ol",[t("li",[s._v("单线程，单线程的好处，减少了内存开销，操作系统的内存换页。")]),s._v(" "),t("li",[s._v("非阻塞I/O， 不会傻等I/O语句结束，而会执行后面的语句。")]),s._v(" "),t("li",[s._v("事件机制，事件环，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。")])]),s._v(" "),t("h2",{attrs:{id:"_2-nodejs适用于哪些场景开发？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-nodejs适用于哪些场景开发？","aria-hidden":"true"}},[s._v("#")]),s._v(" 2. NodeJs适用于哪些场景开发？")]),s._v(" "),t("p",[s._v("善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。\n当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。\n比如：\n● 用户表单收集\n● 考试系统\n● 聊天室\n● 图文直播\n● 提供JSON的API（为前台Angular使用）\n目前有用到的比如，知乎的站内信（表单收集），百度的登录（表单收集），12306（全站都是nodejs开发，因为比较多的I/O操作），功夫熊猫，全站也是nodejs开发的")]),s._v(" "),t("h2",{attrs:{id:"_3-你是怎么调试nodejs呢？有哪些方法？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-你是怎么调试nodejs呢？有哪些方法？","aria-hidden":"true"}},[s._v("#")]),s._v(" 3. 你是怎么调试NodeJs呢？有哪些方法？")]),s._v(" "),t("ul",[t("li",[s._v("打日志")]),s._v(" "),t("li",[s._v("断点调试")]),s._v(" "),t("li",[s._v("vscode")]),s._v(" "),t("li",[s._v("IDE调试")])]),s._v(" "),t("h2",{attrs:{id:"_4-你知道nodejs是如何工作的吗？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-你知道nodejs是如何工作的吗？","aria-hidden":"true"}},[s._v("#")]),s._v(" 4. 你知道NodeJs是如何工作的吗？")]),s._v(" "),t("p",[s._v("NodeJS的工作原理其实就是事件循环。可以说每一条NodeJS的逻辑都是写在回调函数里面的，而回调函数都是有返回之后才异步执行的！")]),s._v(" "),t("p",[s._v("事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。")]),s._v(" "),t("p",[s._v("  事件源：产生事件的地方(html元素)")]),s._v(" "),t("p",[s._v("  事件：点击/鼠标操作/键盘操作等等")]),s._v(" "),t("p",[s._v("  事件对象：当某个事件发生时，可能会产生一个事件对象，该时间对象会封装好该时间的信息，传递给事件处理程序")]),s._v(" "),t("p",[s._v("  事件处理程序：响应用户事件的代码")]),s._v(" "),t("h2",{attrs:{id:"_5-nodejs和v8引擎是什么关系？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-nodejs和v8引擎是什么关系？","aria-hidden":"true"}},[s._v("#")]),s._v(" 5. NodeJs和V8引擎是什么关系？")]),s._v(" "),t("p",[s._v("Node.js是一个基于Google Chrome V8 Javascript引擎之上的平台，用以创建轻量级、快速、可扩展、事件驱动和非阻塞I/O的应用。现在我们来说说Node.js的源头——V8 javascript引擎")]),s._v(" "),t("p",[s._v("V8是Google主导的一个开源项目，它是Chrome浏览器的核心。它首次公开发布是在2008年9月2日，这天也是Chrome浏览器的首个版本发布。它是浏览器性能的一次飞跃，它将浏览器技术推向了一个全新的高度。它使用C++写成，它革命性的创举是将Javascript源码预编译为机器码，而不是像以前那样将Javascript翻译为字节码，然后在运行时使用JIT动态执行代码。")]),s._v(" "),t("h2",{attrs:{id:"_6-nodejs是基于单线程的吗？为什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-nodejs是基于单线程的吗？为什么？","aria-hidden":"true"}},[s._v("#")]),s._v(" 6. NodeJs是基于单线程的吗？为什么？")]),s._v(" "),t("p",[s._v("node.js采用单线程异步非阻塞模式，也就是说每一个计算独占cpu，遇到I/O请求不阻塞后面的计算，当I/O完成后，以事件的方式通知，继续执行计算")]),s._v(" "),t("p",[s._v("我们可以看到，Node.js 的结构大致分为三个层次：")]),s._v(" "),t("p",[s._v("1、 Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。")]),s._v(" "),t("p",[s._v("2、 Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。")]),s._v(" "),t("p",[s._v("3、这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。\nV8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。\nLibuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。\nC-ares：提供了异步处理 DNS 相关的能力。\nhttp_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。")]),s._v(" "),t("h2",{attrs:{id:"_7-nodejs既然是单线程，如何实现异步、非阻塞i-o？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-nodejs既然是单线程，如何实现异步、非阻塞i-o？","aria-hidden":"true"}},[s._v("#")]),s._v(" 7. nodejs既然是单线程，如何实现异步、非阻塞I/O？")]),s._v(" "),t("p",[s._v("而node.js采用单线程异步非阻塞模式，也就是说每一个计算独占cpu，遇到I/O请求不阻塞后面的计算，当I/O完成后，以事件的方式通知，继续执行计算2。")]),s._v(" "),t("p",[s._v("事件驱动、异步、单线程、非阻塞I/O，这是我们听得最多的关于nodejs的介绍。看到上面的关键字，可能我们会")]),s._v(" "),t("p",[s._v("我们可以看到，Node.js 的结构大致分为三个层次：")]),s._v(" "),t("p",[s._v("1、 Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。")]),s._v(" "),t("p",[s._v("2、 Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。")]),s._v(" "),t("p",[s._v("3、这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。")]),s._v(" "),t("p",[s._v("V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。\nLibuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。\nC-ares：提供了异步处理 DNS 相关的能力。\nhttp_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。")]),s._v(" "),t("p",[s._v("可以看出，几乎所有和操作系统打交道的部分都离不开 libuv的支持。libuv也是node实现跨操作系统的核心所在。")]),s._v(" "),t("p",[s._v("四、我们再来看看最开始我抛出的问题\n问题一：为什么在浏览器中运行的 Javascript 能与操作系统进行如此底层的交互？\n举个简单的例子，我们想要打开一个文件，并进行一些操作，可以写下面这样一段代码：")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" fs "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'fs'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" \nfs"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("open")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'./test.txt'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"w"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("err"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" fd")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("     \n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//..do something ")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("  \nfs"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("open")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("path"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" flags"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" mode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" callback")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("      \n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// ...     ")]),s._v("\n  binding"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("open")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("pathModule"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("_makeLong")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("path"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("                         \n  "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("stringToFlags")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("flags"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("  mode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("  callback"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("  \n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[s._v("这段代码的调用过程大致可描述为：lib/fs.js → src/node_file.cc →uv_fs")]),s._v(" "),t("p",[s._v("从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过 libuv进行系统调用，这是Node里经典的调用方式。总体来说，我们在 Javascript 中调用的方法，最终都会通过node-bindings 传递到 C/C++ 层面，最终由他们来执行真正的操作。Node.js 即这样与操作系统进行互动。")]),s._v(" "),t("h2",{attrs:{id:"_8-nodejs既然是单线程，如何实现异步、非阻塞i-o？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-nodejs既然是单线程，如何实现异步、非阻塞i-o？","aria-hidden":"true"}},[s._v("#")]),s._v(" 8. nodejs既然是单线程，如何实现异步、非阻塞I/O？")]),s._v(" "),t("p",[s._v("顺便回答标题nodejs真的是单线程吗？其实只有js执行是单线程，I/O显然是其它线程。\njs执行线程是单线程，把需要做的I/O交给libuv，自己马上返回做别的事情，然后libuv在指定的时刻回调就行了。其实简化的流程就是酱紫的！细化一点，nodejs会先从js代码通过node-bindings调用到C/C++代码，然后通过C/C++代码封装一个叫 “请求对象” 的东西交给libuv，这个请求对象里面无非就是需要执行的功能+回调之类的东西，给libuv执行以及执行完实现回调。")]),s._v(" "),t("p",[s._v("总结来说，一个异步 I/O 的大致流程如下：")]),s._v(" "),t("p",[s._v("1、发起 I/O 调用\n用户通过 Javascript 代码调用 Node 核心模块，将参数和回调函数传入到核心模块；\nNode 核心模块会将传入的参数和回调函数封装成一个请求对象；\n将这个请求对象推入到 I/O 线程池等待执行；\nJavascript 发起的异步调用结束，Javascript 线程继续执行后续操作。")]),s._v(" "),t("p",[s._v("2、执行回调\nI/O 操作完成后，会取出之前封装在请求对象中的回调函数，执行这个回调函数，以完成 Javascript 回调的目的。（这里回调的细节下面讲解）")]),s._v(" "),t("p",[s._v("从这里，我们可以看到，我们其实对 Node.js 的单线程一直有个误会。事实上，它的单线程指的是自身 Javascript 运行环境的单线程，Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作，还是通过 Libuv 以及它的事件循环来执行的。这也就是为什么 Javascript 一个单线程的语言，能在 Node.js 里面实现异步操作的原因，两者并不冲突。")]),s._v(" "),t("h2",{attrs:{id:"_9-nodejs全是异步调用和非阻塞i-o，就真的不用管并发数了吗？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-nodejs全是异步调用和非阻塞i-o，就真的不用管并发数了吗？","aria-hidden":"true"}},[s._v("#")]),s._v(" 9. nodejs全是异步调用和非阻塞I/O，就真的不用管并发数了吗？")]),s._v(" "),t("p",[s._v("之前我们就提到了线程池的概念，发现nodejs并不是单线程的，而且还有并行事件发生。同时，线程池默认大小是 4 ，也就是说，同时能有4个线程去做文件i/o的工作，剩下的请求会被挂起等待直到线程池有空闲。 所以nodejs对于并发数，是由限制的。\n线程池的大小可以通过 UV_THREADPOOL_SIZE 这个环境变量来改变 或者在nodejs代码中通过 process.env.UV_THREADPOOL_SIZE来重新设置。")]),s._v(" "),t("h2",{attrs:{id:"_10-nodejs事件驱动是如何实现的？和浏览器的event-loop是一回事吗？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-nodejs事件驱动是如何实现的？和浏览器的event-loop是一回事吗？","aria-hidden":"true"}},[s._v("#")]),s._v(" 10. nodejs事件驱动是如何实现的？和浏览器的event loop是一回事吗？")]),s._v(" "),t("p",[s._v("event loop是一个执行模型，在不同的地方有不同的实现。浏览器和nodejs基于不同的技术实现了各自的event loop。")]),s._v(" "),t("p",[s._v("简单来说：")]),s._v(" "),t("p",[s._v("nodejs的event是基于libuv，而浏览器的event loop则在html5的规范中明确定义。\nlibuv已经对event loop作出了实现，而html5规范中只是定义了浏览器中event loop的模型，具体实现留给了浏览器厂商。")]),s._v(" "),t("p",[s._v("我们上面提到了libuv接过了js传递过来的 I/O请求，那么何时来处理回调呢？")]),s._v(" "),t("p",[s._v("libuv有一个事件循环(event loop)的机制，来接受和管理回调函数的执行。")]),s._v(" "),t("p",[s._v("event loop是libuv的核心所在，上面我们提到 js 会把回调和任务交给libuv，libuv何时来调用回调就是 event loop 来控制的。event loop 首先会在内部维持多个事件队列（或者叫做观察者 watcher），比如 时间队列、网络队列等等，使用者可以在watcher中注册回调，当事件发生时事件转入pending状态，再下一次循环的时候按顺序取出来执行，而libuv会执行一个相当于 while true的无限循环，不断的检查各个watcher上面是否有需要处理的pending状态事件，如果有则按顺序去触发队列里面保存的事件，同时由于libuv的事件循环每次只会执行一个回调，从而避免了 竞争的发生。")]),s._v(" "),t("p",[s._v('nodejs的event loop分为6个阶段，每个阶段的作用如下：\ntimers：执行setTimeout() 和 setInterval()中到期的callback。\nI/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行\nidle, prepare：仅内部使用\npoll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段\ncheck：执行setImmediate的callback\nclose callbacks：执行close事件的callback，例如socket.on("close",func)')]),s._v(" "),t("p",[s._v("event loop的每一次循环都需要依次经过上述的阶段。 每个阶段都有自己的callback队列，每当进入某个阶段，都会从所属的队列中取出callback来执行，当队列为空或者被执行callback的数量达到系统的最大数量时，进入下一阶段。这六个阶段都执行完毕称为一轮循环。")]),s._v(" "),t("h2",{attrs:{id:"_11-nodejs擅长什么？不擅长什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-nodejs擅长什么？不擅长什么？","aria-hidden":"true"}},[s._v("#")]),s._v(" 11. nodejs擅长什么？不擅长什么？")]),s._v(" "),t("p",[s._v("Node.js 通过 libuv 来处理与操作系统的交互，并且因此具备了异步、非阻塞、事件驱动的能力。因此，NodeJS能响应大量的并发请求。所以，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。")]),s._v(" "),t("p",[s._v("上面提到，如果是 I/O 任务，Node.js 就把任务交给线程池来异步处理，高效简单，因此 Node.js 适合处理I/O密集型任务。但不是所有的任务都是 I/O 密集型任务，当碰到CPU密集型任务时，即只用CPU计算的操作，比如要对数据加解密(node.bcrypt.js)，数据压缩和解压(node-tar)，这时 Node.js 就会亲自处理，一个一个的计算，前面的任务没有执行完，后面的任务就只能干等着")]),s._v(" "),t("p",[s._v("其实虽然Node.js可以处理数以千记的并发，但是一个Node.js进程在某一时刻其实只是在处理一个请求。")]),s._v(" "),t("p",[s._v("因此，Node.js 并不适合 CPU 密集型任务。")]),s._v(" "),t("h2",{attrs:{id:"_12-nodejs的回调有什么用吗？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-nodejs的回调有什么用吗？","aria-hidden":"true"}},[s._v("#")]),s._v(" 12. NodeJs的回调有什么用吗？")]),s._v(" "),t("p",[s._v("Node.js 异步编程的直接体现就是回调。")]),s._v(" "),t("p",[s._v("异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。")]),s._v(" "),t("p",[s._v("回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。")]),s._v(" "),t("p",[s._v("例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。")]),s._v(" "),t("h2",{attrs:{id:"_13-node的全局对象-和-全局变量有哪些？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-node的全局对象-和-全局变量有哪些？","aria-hidden":"true"}},[s._v("#")]),s._v(" 13. Node的全局对象 和 全局变量有哪些？")]),s._v(" "),t("p",[s._v("1、全局对象")]),s._v(" "),t("p",[s._v("所有模块都可以调用")]),s._v(" "),t("p",[s._v("1）global：表示Node所在的全局环境，类似于浏览器中的window对象。")]),s._v(" "),t("p",[s._v("2）process：指向Node内置的process模块，允许开发者与当前进程互动。")]),s._v(" "),t("p",[s._v("例如你在DOS或终端窗口直接输入node，就会进入NODE的命令行方式（REPL环境）。退出要退出的话，可以输入 process.exit();")]),s._v(" "),t("p",[s._v("3）console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。")]),s._v(" "),t("p",[s._v("通常是写console.log()，无须多言")]),s._v(" "),t("p",[s._v("2、全局函数：")]),s._v(" "),t("p",[s._v("1）定时器函数：共有4个，分别是setTimeout(), clearTimeout(), setInterval(), clearInterval()。\n2）require：用于加载模块。")]),s._v(" "),t("p",[s._v("3、全局变量：")]),s._v(" "),t("ol",[t("li",[s._v("_filename：指向当前运行的脚本文件名。")]),s._v(" "),t("li",[s._v("_dirname：指向当前运行的脚本所在的目录。")])]),s._v(" "),t("p",[s._v("4、准全局变量")]),s._v(" "),t("p",[s._v("模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。")]),s._v(" "),t("p",[s._v("module变量指代当前模块。module.exports变量表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。")]),s._v(" "),t("p",[s._v("module.id 模块的识别符，通常是模块的文件名。\nmodule.filename 模块的文件名。\nmodule.loaded 返回一个布尔值，表示模块是否已经完成加载。\nmodule.parent 返回使用该模块的模块。")]),s._v(" "),t("p",[s._v("module.children 返回一个数组，表示该模块要用到的其他模块。")]),s._v(" "),t("p",[s._v("这里需要特别指出的是，exports变量实际上是一个指向module.exports对象的链接，等同在每个模块头部，有一行这样的命令。")]),s._v(" "),t("p",[s._v("var exports = module.exports;")]),s._v(" "),t("p",[s._v("这造成的结果是，在对外输出模块接口时，可以向exports对象添加方法，但是不能直接将exports变量指向一个函数：")]),s._v(" "),t("p",[s._v("exports = function (x){ console.log(x);};")]),s._v(" "),t("p",[s._v("上面这样的写法是无效的，因为它切断了exports与module.exports之间的链接。但是，下面这样写是可以的。")]),s._v(" "),t("h2",{attrs:{id:"_14-怎样在nodejs中加载html文件？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-怎样在nodejs中加载html文件？","aria-hidden":"true"}},[s._v("#")]),s._v(" 14. 怎样在NodeJs中加载HTML文件？")]),s._v(" "),t("h2",{attrs:{id:"_15-请解释下你对eventemitter的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-请解释下你对eventemitter的理解","aria-hidden":"true"}},[s._v("#")]),s._v(" 15. 请解释下你对EventEmitter的理解")]),s._v(" "),t("h2",{attrs:{id:"_16-你知道什么是repl吗？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-你知道什么是repl吗？","aria-hidden":"true"}},[s._v("#")]),s._v(" 16. 你知道什么是REPL吗？")]),s._v(" "),t("h2",{attrs:{id:"_17-npm是干什么用的？它有什么优缺点？有没有类似的方案？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-npm是干什么用的？它有什么优缺点？有没有类似的方案？","aria-hidden":"true"}},[s._v("#")]),s._v(" 17. npm是干什么用的？它有什么优缺点？有没有类似的方案？")]),s._v(" "),t("h2",{attrs:{id:"_18-说说你对package-json的理解，它都有哪些作用？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-说说你对package-json的理解，它都有哪些作用？","aria-hidden":"true"}},[s._v("#")]),s._v(" 18.说说你对package.json的理解，它都有哪些作用？")]),s._v(" "),t("h2",{attrs:{id:"_19-你了解nodejs的子进程吗？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-你了解nodejs的子进程吗？","aria-hidden":"true"}},[s._v("#")]),s._v(" 19. 你了解NodeJs的子进程吗？")]),s._v(" "),t("h2",{attrs:{id:"_20-你用nodejs做过什么项目？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-你用nodejs做过什么项目？","aria-hidden":"true"}},[s._v("#")]),s._v(" 20. 你用NodeJs做过什么项目？")])])}),[],!1,null,null,null);e.default=n.exports}}]);